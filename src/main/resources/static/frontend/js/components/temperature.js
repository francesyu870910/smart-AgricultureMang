/**
 * Êô∫ËÉΩÊ∏©ÂÆ§ÁéØÂ¢ÉÁõëÊéßÁ≥ªÁªü - Ê∏©Â∫¶ÁõëÊéßÁªÑ‰ª∂
 */

class TemperatureComponent {
    constructor() {
        this.refreshInterval = null;
        this.currentData = null;
        this.historyData = [];
        this.thresholds = {
            min: 18,
            max: 30,
            optimal: { min: 20, max: 28 }
        };
        this.chartCanvas = null;
    }

    async render() {
        return `
            <div class="temperature-container">
                <!-- Ê∏©Â∫¶Êï∞ÊçÆÊ¶ÇËßàÂç°Áâá -->
                <div class="grid grid-3">
                    <div class="data-card">
                        <div class="card-header">
                            <h3 class="card-title">
                                <span class="icon-temperature"></span>
                                ÂΩìÂâçÊ∏©Â∫¶
                            </h3>
                            <div class="card-actions">
                                <button class="btn btn-refresh" onclick="temperatureComponent.refresh()">
                                    <span class="icon-refresh"></span>
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="data-display">
                                <div class="data-value" id="current-temperature">
                                    <span id="temp-value">--</span>
                                    <span class="data-unit">¬∞C</span>
                                    <span id="temp-status" class="data-status status-normal">Ê≠£Â∏∏</span>
                                </div>
                                <div class="progress-bar">
                                    <div id="temp-progress" class="progress-fill" style="width: 0%"></div>
                                </div>
                            </div>
                            <div class="data-display">
                                <div class="data-label">‰º†ÊÑüÂô®Áä∂ÊÄ?/div>
                                <div class="data-value">
                                    <span id="sensor-status" class="tag tag-success">Âú®Á∫ø</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="data-card">
                        <div class="card-header">
                            <h3 class="card-title">Ê∏©Â∫¶ÁªüËÆ°</h3>
                        </div>
                        <div class="card-body">
                            <div class="data-display">
                                <div class="data-label">ÊúÄÈ´òÊ∏©Â∫?/div>
                                <div class="data-value">
                                    <span id="max-temp">--</span>
                                    <span class="data-unit">¬∞C</span>
                                </div>
                            </div>
                            <div class="data-display">
                                <div class="data-label">ÊúÄ‰ΩéÊ∏©Â∫?/div>
                                <div class="data-value">
                                    <span id="min-temp">--</span>
                                    <span class="data-unit">¬∞C</span>
                                </div>
                            </div>
                            <div class="data-display">
                                <div class="data-label">Âπ≥ÂùáÊ∏©Â∫¶</div>
                                <div class="data-value">
                                    <span id="avg-temp">--</span>
                                    <span class="data-unit">¬∞C</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="data-card">
                        <div class="card-header">
                            <h3 class="card-title">Ê∏©Â∫¶Ë∂ãÂäø</h3>
                        </div>
                        <div class="card-body">
                            <div class="gauge-chart" id="temp-gauge">
                                <canvas id="temperature-gauge-canvas" width="180" height="180"></canvas>
                            </div>
                            <div class="trend-indicator" id="temp-trend">
                                <span class="trend-arrow"></span>
                                <span id="trend-text">Á®≥ÂÆö</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Ê∏©Â∫¶Ë∂ãÂäøÂõæË°® -->
                <div class="chart-container">
                    <div class="chart-header">
                        <h3 class="chart-title">24Â∞èÊó∂Ê∏©Â∫¶ÂèòÂåñË∂ãÂäø</h3>
                        <div class="chart-controls">
                            <div class="chart-period">
                                <button class="period-btn active" data-period="24h">24Â∞èÊó∂</button>
                                <button class="period-btn" data-period="7d">7Â§?/button>
                                <button class="period-btn" data-period="30d">30Â§?/button>
                            </div>
                            <button class="btn btn-secondary" onclick="temperatureComponent.exportData()">
                                ÂØºÂá∫Êï∞ÊçÆ
                            </button>
                        </div>
                    </div>
                    <div class="line-chart">
                        <canvas id="temperature-chart-canvas" width="800" height="300"></canvas>
                        <div class="chart-axis x-axis" id="chart-x-axis">
                            <!-- Êó∂Èó¥ËΩ¥Ê†áÁ≠æÂ∞ÜÈÄöËøáJavaScriptÂä®ÊÄÅÁîüÊà?-->
                        </div>
                        <div class="chart-axis y-axis" id="chart-y-axis">
                            <!-- Ê∏©Â∫¶ËΩ¥Ê†áÁ≠æÂ∞ÜÈÄöËøáJavaScriptÂä®ÊÄÅÁîüÊà?-->
                        </div>
                    </div>
                    <div class="chart-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #2E7D32;"></div>
                            <span>ÂÆûÊó∂Ê∏©Â∫¶</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FF9800;"></div>
                            <span>Ë≠¶ÂëäÈòàÂÄ?/span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #F44336;"></div>
                            <span>Âç±Èô©ÈòàÂÄ?/span>
                        </div>
                    </div>
                </div>

                <!-- Ê∏©Â∫¶ÈòàÂÄºËÆæÁΩ?-->
                <div class="data-card">
                    <div class="card-header">
                        <h3 class="card-title">Ê∏©Â∫¶ÈòàÂÄºËÆæÁΩ?/h3>
                        <div class="card-actions">
                            <button class="btn btn-primary" onclick="temperatureComponent.saveThresholds()">
                                ‰øùÂ≠òËÆæÁΩÆ
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="grid grid-2">
                            <div class="form-group">
                                <label class="form-label">ÊúÄ‰ΩéÊ∏©Â∫¶ÈòàÂÄ?(¬∞C)</label>
                                <input type="number" id="min-threshold" class="form-input" 
                                       value="${this.thresholds.min}" min="0" max="50" step="0.1">
                            </div>
                            <div class="form-group">
                                <label class="form-label">ÊúÄÈ´òÊ∏©Â∫¶ÈòàÂÄ?(¬∞C)</label>
                                <input type="number" id="max-threshold" class="form-input" 
                                       value="${this.thresholds.max}" min="0" max="50" step="0.1">
                            </div>
                            <div class="form-group">
                                <label class="form-label">ÊúÄÈÄÇÊ∏©Â∫¶‰∏ãÈô?(¬∞C)</label>
                                <input type="number" id="optimal-min-threshold" class="form-input" 
                                       value="${this.thresholds.optimal.min}" min="0" max="50" step="0.1">
                            </div>
                            <div class="form-group">
                                <label class="form-label">ÊúÄÈÄÇÊ∏©Â∫¶‰∏äÈô?(¬∞C)</label>
                                <input type="number" id="optimal-max-threshold" class="form-input" 
                                       value="${this.thresholds.optimal.max}" min="0" max="50" step="0.1">
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Ê∏©Â∫¶ÂºÇÂ∏∏Â§ÑÁêÜ</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="checkbox" id="auto-alert" checked>
                                    Ëá™Âä®Êä•Ë≠¶
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px;">
                                    <input type="checkbox" id="auto-control" checked>
                                    Ëá™Âä®Ë∞ÉËäÇ
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Ê∏©Â∫¶ÂºÇÂ∏∏ËÆ∞ÂΩï -->
                <div class="data-card">
                    <div class="card-header">
                        <h3 class="card-title">Ê∏©Â∫¶ÂºÇÂ∏∏ËÆ∞ÂΩï</h3>
                        <div class="card-actions">
                            <button class="btn btn-secondary" onclick="temperatureComponent.clearAlerts()">
                                Ê∏ÖÈô§ËÆ∞ÂΩï
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div id="temperature-alerts">
                            <!-- ÂºÇÂ∏∏ËÆ∞ÂΩïÂ∞ÜÈÄöËøáJavaScriptÂä®ÊÄÅÁîüÊà?-->
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    async init() {
        console.log('Ê∏©Â∫¶ÁõëÊéßÁªÑ‰ª∂ÂàùÂßãÂåñ‰∏≠...');
        
        // ÂàùÂßãÂåñÂõæË°®ÁîªÂ∏?
        this.initCharts();
        
        // ÁªëÂÆö‰∫ã‰ª∂ÁõëÂê¨Âô?
        this.bindEvents();
        
        // Âä†ËΩΩÂàùÂßãÊï∞ÊçÆ
        await this.loadInitialData();
        
        // ÂêØÂä®ÂÆöÊó∂Âà∑Êñ∞
        this.startAutoRefresh();
        
        console.log('Ê∏©Â∫¶ÁõëÊéßÁªÑ‰ª∂Â∑≤ÂàùÂßãÂåñ');
    }

    /**
     * ÂàùÂßãÂåñÂõæË°?
     */
    initCharts() {
        // ÂàùÂßãÂåñÊ∏©Â∫¶‰ª™Ë°®Áõò
        setTimeout(() => {
            const gaugeCanvas = document.getElementById('temperature-gauge-canvas');
            if (gaugeCanvas) {
                this.drawGauge(25, 0, 50);
            }
            
            // ÂàùÂßãÂåñË∂ãÂäøÂõæË°?
            const chartCanvas = document.getElementById('temperature-chart-canvas');
            if (chartCanvas) {
                this.chartCanvas = chartCanvas;
                this.drawTrendChart();
            }
        }, 100);
    }

    /**
     * ÁªëÂÆö‰∫ã‰ª∂ÁõëÂê¨Âô?
     */
    bindEvents() {
        // Êó∂Èó¥Âë®ÊúüÂàáÊç¢
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('period-btn')) {
                // ÁßªÈô§ÂÖ∂‰ªñÊåâÈíÆÁöÑactiveÁ±?
                document.querySelectorAll('.period-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                // Ê∑ªÂä†ÂΩìÂâçÊåâÈíÆÁöÑactiveÁ±?
                e.target.classList.add('active');
                
                // ÈáçÊñ∞Âä†ËΩΩÂØπÂ∫îÂë®ÊúüÁöÑÊï∞Êç?
                const period = e.target.dataset.period;
                this.loadHistoryData(period);
            }
        });

        // ÈòàÂÄºËæìÂÖ•È™åËØ?
        ['min-threshold', 'max-threshold', 'optimal-min-threshold', 'optimal-max-threshold'].forEach(id => {
            const input = document.getElementById(id);
            if (input) {
                input.addEventListener('change', () => {
                    this.validateThresholds();
                });
            }
        });
    }

    /**
     * Âä†ËΩΩÂàùÂßãÊï∞ÊçÆ
     */
    async loadInitialData() {
        try {
            // Âä†ËΩΩÂΩìÂâçÁéØÂ¢ÉÊï∞ÊçÆ
            await this.refresh();
            
            // Âä†ËΩΩÂéÜÂè≤Êï∞ÊçÆ
            await this.loadHistoryData('24h');
            
        } catch (error) {
            console.error('Âä†ËΩΩÊ∏©Â∫¶Êï∞ÊçÆÂ§±Ë¥•:', error);
            notificationUtils.error('Âä†ËΩΩÊ∏©Â∫¶Êï∞ÊçÆÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé?);
        }
    }

    /**
     * Âà∑Êñ∞Ê∏©Â∫¶Êï∞ÊçÆ
     */
    async refresh() {
        try {
            const response = await apiService.getCurrentEnvironmentData();
            
            if (response && response.data) {
                this.currentData = response.data;
                this.updateDisplay();
                this.updateGauge();
                this.checkThresholds();
            }
        } catch (error) {
            console.error('Âà∑Êñ∞Ê∏©Â∫¶Êï∞ÊçÆÂ§±Ë¥•:', error);
            // ‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆ‰Ωú‰∏∫Â§áÁî®
            this.currentData = this.generateMockData();
            this.updateDisplay();
            this.updateGauge();
        }
    }

    /**
     * Êõ¥Êñ∞ÊòæÁ§∫Êï∞ÊçÆ
     */
    updateDisplay() {
        if (!this.currentData) return;

        const temperature = parseFloat(this.currentData.temperature);
        
        // Êõ¥Êñ∞ÂΩìÂâçÊ∏©Â∫¶ÊòæÁ§∫
        const tempValueEl = document.getElementById('temp-value');
        const tempStatusEl = document.getElementById('temp-status');
        const tempProgressEl = document.getElementById('temp-progress');
        
        if (tempValueEl) {
            tempValueEl.textContent = temperature.toFixed(1);
        }
        
        // Êõ¥Êñ∞Ê∏©Â∫¶Áä∂ÊÄÅÂíåËøõÂ∫¶Êù?
        if (tempStatusEl && tempProgressEl) {
            const status = this.getTemperatureStatus(temperature);
            tempStatusEl.textContent = status.text;
            tempStatusEl.className = `data-status ${status.class}`;
            
            // Êõ¥Êñ∞ËøõÂ∫¶Êù?
            const progress = ((temperature - 0) / 50) * 100;
            tempProgressEl.style.width = `${Math.min(100, Math.max(0, progress))}%`;
            tempProgressEl.className = `progress-fill ${status.progressClass}`;
        }
        
        // Êõ¥Êñ∞‰º†ÊÑüÂô®Áä∂ÊÄ?
        const sensorStatusEl = document.getElementById('sensor-status');
        if (sensorStatusEl) {
            sensorStatusEl.textContent = 'Âú®Á∫ø';
            sensorStatusEl.className = 'tag tag-success';
        }
        
        // Êõ¥Êñ∞ÁªüËÆ°Êï∞ÊçÆ
        this.updateStatistics();
        
        // Êõ¥Êñ∞Ë∂ãÂäøÊåáÁ§∫Âô?
        this.updateTrendIndicator();
    }

    /**
     * Ëé∑ÂèñÊ∏©Â∫¶Áä∂ÊÄ?
     */
    getTemperatureStatus(temperature) {
        if (temperature < this.thresholds.min) {
            return {
                text: 'Ëøá‰Ωé',
                class: 'status-danger',
                progressClass: 'danger'
            };
        } else if (temperature > this.thresholds.max) {
            return {
                text: 'ËøáÈ´ò',
                class: 'status-danger',
                progressClass: 'danger'
            };
        } else if (temperature < this.thresholds.optimal.min || temperature > this.thresholds.optimal.max) {
            return {
                text: 'Ë≠¶Âëä',
                class: 'status-warning',
                progressClass: 'warning'
            };
        } else {
            return {
                text: 'Ê≠£Â∏∏',
                class: 'status-normal',
                progressClass: ''
            };
        }
    }

    /**
     * Êõ¥Êñ∞ÁªüËÆ°Êï∞ÊçÆ
     */
    updateStatistics() {
        if (this.historyData.length === 0) return;
        
        const temperatures = this.historyData.map(d => parseFloat(d.temperature));
        const maxTemp = Math.max(...temperatures);
        const minTemp = Math.min(...temperatures);
        const avgTemp = temperatures.reduce((a, b) => a + b, 0) / temperatures.length;
        
        const maxTempEl = document.getElementById('max-temp');
        const minTempEl = document.getElementById('min-temp');
        const avgTempEl = document.getElementById('avg-temp');
        
        if (maxTempEl) maxTempEl.textContent = maxTemp.toFixed(1);
        if (minTempEl) minTempEl.textContent = minTemp.toFixed(1);
        if (avgTempEl) avgTempEl.textContent = avgTemp.toFixed(1);
    }

    /**
     * Êõ¥Êñ∞Ë∂ãÂäøÊåáÁ§∫Âô?
     */
    updateTrendIndicator() {
        if (this.historyData.length < 2) return;
        
        const recent = this.historyData.slice(-5).map(d => parseFloat(d.temperature));
        const trend = this.calculateTrend(recent);
        
        const trendEl = document.getElementById('temp-trend');
        const trendTextEl = document.getElementById('trend-text');
        
        if (trendEl && trendTextEl) {
            if (trend > 0.5) {
                trendEl.className = 'trend-indicator trend-up';
                trendTextEl.textContent = '‰∏äÂçá';
            } else if (trend < -0.5) {
                trendEl.className = 'trend-indicator trend-down';
                trendTextEl.textContent = '‰∏ãÈôç';
            } else {
                trendEl.className = 'trend-indicator trend-stable';
                trendTextEl.textContent = 'Á®≥ÂÆö';
            }
        }
    }

    /**
     * ËÆ°ÁÆóË∂ãÂäø
     */
    calculateTrend(data) {
        if (data.length < 2) return 0;
        
        const first = data[0];
        const last = data[data.length - 1];
        return last - first;
    }

    /**
     * Êõ¥Êñ∞‰ª™Ë°®Áõ?
     */
    updateGauge() {
        if (!this.currentData) return;
        
        const temperature = parseFloat(this.currentData.temperature);
        this.drawGauge(temperature, 0, 50);
    }

    /**
     * ÁªòÂà∂Ê∏©Â∫¶‰ª™Ë°®Áõ?
     */
    drawGauge(value, min, max) {
        const canvas = document.getElementById('temperature-gauge-canvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const rect = canvas.getBoundingClientRect();
        
        // ËÆæÁΩÆcanvasÂÆûÈôÖÂ§ßÂ∞è
        canvas.width = rect.width;
        canvas.height = rect.height;
        
        // Ê∏ÖÁ©∫ÁîªÂ∏É
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(centerX, centerY) - 20;
        
        // ÁªòÂà∂ËÉåÊôØÂºßÁ∫ø
        const startAngle = Math.PI;
        const endAngle = 2 * Math.PI;
        const totalAngle = endAngle - startAngle;
        
        // ÁªòÂà∂Ê∏©Â∫¶Âå∫Èó¥ÂºßÁ∫ø
        const segments = [
            { color: '#4CAF50', start: 0, end: 0.6 },      // Ê≠£Â∏∏Âå∫Èó¥
            { color: '#FF9800', start: 0.6, end: 0.8 },    // Ë≠¶ÂëäÂå∫Èó¥
            { color: '#F44336', start: 0.8, end: 1.0 }     // Âç±Èô©Âå∫Èó¥
        ];
        
        segments.forEach(segment => {
            const segmentStartAngle = startAngle + totalAngle * segment.start;
            const segmentEndAngle = startAngle + totalAngle * segment.end;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, segmentStartAngle, segmentEndAngle);
            ctx.lineWidth = 15;
            ctx.strokeStyle = segment.color;
            ctx.stroke();
        });
        
        // ÁªòÂà∂ÊåáÈíà
        const valueAngle = startAngle + ((value - min) / (max - min)) * totalAngle;
        const needleLength = radius - 25;
        
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(
            centerX + Math.cos(valueAngle) * needleLength,
            centerY + Math.sin(valueAngle) * needleLength
        );
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#2E7D32';
        ctx.stroke();
        
        // ÁªòÂà∂‰∏≠ÂøÉÁÇ?
        ctx.beginPath();
        ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
        ctx.fillStyle = '#2E7D32';
        ctx.fill();
        
        // ÁªòÂà∂Êï∞ÂÄºÊñáÊú?
        ctx.fillStyle = '#333';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(value.toFixed(1) + '¬∞C', centerX, centerY + 35);
    }

    /**
     * Âä†ËΩΩÂéÜÂè≤Êï∞ÊçÆ
     */
    async loadHistoryData(period = '24h') {
        try {
            const params = {
                period: period,
                type: 'temperature'
            };
            
            const response = await apiService.getEnvironmentHistory(params);
            
            if (response && response.data) {
                this.historyData = response.data;
            } else {
                // ÁîüÊàêÊ®°ÊãüÂéÜÂè≤Êï∞ÊçÆ
                this.historyData = this.generateMockHistoryData(period);
            }
            
            this.drawTrendChart();
            this.updateStatistics();
            
        } catch (error) {
            console.error('Âä†ËΩΩÂéÜÂè≤Êï∞ÊçÆÂ§±Ë¥•:', error);
            // ‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆ
            this.historyData = this.generateMockHistoryData(period);
            this.drawTrendChart();
        }
    }

    /**
     * ÁªòÂà∂Ë∂ãÂäøÂõæË°®
     */
    drawTrendChart() {
        if (!this.chartCanvas || this.historyData.length === 0) return;
        
        const chartData = this.historyData.map((item, index) => ({
            value: parseFloat(item.temperature),
            label: this.formatTimeLabel(item.recordedAt || new Date(Date.now() - (this.historyData.length - index) * 60000))
        }));
        
        const ctx = this.chartCanvas.getContext('2d');
        const rect = this.chartCanvas.getBoundingClientRect();
        
        // ËÆæÁΩÆcanvasÂÆûÈôÖÂ§ßÂ∞è
        this.chartCanvas.width = rect.width;
        this.chartCanvas.height = rect.height;
        
        // Ê∏ÖÁ©∫ÁîªÂ∏É
        ctx.clearRect(0, 0, this.chartCanvas.width, this.chartCanvas.height);
        
        if (chartData.length === 0) return;
        
        // ÈÖçÁΩÆÂèÇÊï∞
        const padding = 40;
        const chartWidth = this.chartCanvas.width - padding * 2;
        const chartHeight = this.chartCanvas.height - padding * 2;
        
        // ËÆ°ÁÆóÊï∞ÊçÆËåÉÂõ¥
        const values = chartData.map(d => d.value);
        const minValue = Math.min(...values);
        const maxValue = Math.max(...values);
        const valueRange = maxValue - minValue || 1;
        
        // ÁªòÂà∂ÁΩëÊ†ºÁ∫?
        this.drawChartGrid(ctx, padding, chartWidth, chartHeight);
        
        // ÁªòÂà∂ÈòàÂÄºÁ∫ø
        this.drawThresholdLines(ctx, padding, chartWidth, chartHeight, minValue, valueRange);
        
        // ÁªòÂà∂Êï∞ÊçÆÁ∫?
        this.drawDataLine(ctx, chartData, padding, chartWidth, chartHeight, minValue, valueRange);
        
        // ÁªòÂà∂Êï∞ÊçÆÁÇ?
        this.drawDataPoints(ctx, chartData, padding, chartWidth, chartHeight, minValue, valueRange);
        
        // Êõ¥Êñ∞ÂùêÊ†áËΩ¥Ê†áÁ≠?
        this.updateChartAxes(chartData);
    }
    
    /**
     * ÁªòÂà∂ÂõæË°®ÁΩëÊ†º
     */
    drawChartGrid(ctx, padding, chartWidth, chartHeight) {
        ctx.strokeStyle = '#E0E0E0';
        ctx.lineWidth = 1;
        
        // Ê∞¥Âπ≥ÁΩëÊ†ºÁ∫?
        for (let i = 0; i <= 5; i++) {
            const y = padding + (chartHeight / 5) * i;
            ctx.beginPath();
            ctx.moveTo(padding, y);
            ctx.lineTo(padding + chartWidth, y);
            ctx.stroke();
        }
        
        // ÂûÇÁõ¥ÁΩëÊ†ºÁ∫?
        for (let i = 0; i <= 6; i++) {
            const x = padding + (chartWidth / 6) * i;
            ctx.beginPath();
            ctx.moveTo(x, padding);
            ctx.lineTo(x, padding + chartHeight);
            ctx.stroke();
        }
    }
    
    /**
     * ÁªòÂà∂ÈòàÂÄºÁ∫ø
     */
    drawThresholdLines(ctx, padding, chartWidth, chartHeight, minValue, valueRange) {
        // ÁªòÂà∂ÊúÄ‰ΩéÈòàÂÄºÁ∫ø
        const minThresholdY = padding + chartHeight - ((this.thresholds.min - minValue) / valueRange) * chartHeight;
        if (minThresholdY >= padding && minThresholdY <= padding + chartHeight) {
            ctx.strokeStyle = '#F44336';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, minThresholdY);
            ctx.lineTo(padding + chartWidth, minThresholdY);
            ctx.stroke();
        }
        
        // ÁªòÂà∂ÊúÄÈ´òÈòàÂÄºÁ∫ø
        const maxThresholdY = padding + chartHeight - ((this.thresholds.max - minValue) / valueRange) * chartHeight;
        if (maxThresholdY >= padding && maxThresholdY <= padding + chartHeight) {
            ctx.strokeStyle = '#F44336';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, maxThresholdY);
            ctx.lineTo(padding + chartWidth, maxThresholdY);
            ctx.stroke();
        }
        
        // ÁªòÂà∂ÊúÄÈÄÇÊ∏©Â∫¶ËåÉÂõ?
        const optimalMinY = padding + chartHeight - ((this.thresholds.optimal.min - minValue) / valueRange) * chartHeight;
        const optimalMaxY = padding + chartHeight - ((this.thresholds.optimal.max - minValue) / valueRange) * chartHeight;
        
        if (optimalMinY >= padding && optimalMinY <= padding + chartHeight && 
            optimalMaxY >= padding && optimalMaxY <= padding + chartHeight) {
            ctx.fillStyle = 'rgba(76, 175, 80, 0.1)';
            ctx.fillRect(padding, optimalMaxY, chartWidth, optimalMinY - optimalMaxY);
        }
        
        // ÈáçÁΩÆÁ∫øÊù°Ê†∑Âºè
        ctx.setLineDash([]);
    }
    
    /**
     * ÁªòÂà∂Êï∞ÊçÆÁ∫?
     */
    drawDataLine(ctx, chartData, padding, chartWidth, chartHeight, minValue, valueRange) {
        ctx.strokeStyle = '#2E7D32';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        chartData.forEach((point, index) => {
            const x = padding + (chartWidth / (chartData.length - 1)) * index;
            const y = padding + chartHeight - ((point.value - minValue) / valueRange) * chartHeight;
            
            if (index === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        ctx.stroke();
    }
    
    /**
     * ÁªòÂà∂Êï∞ÊçÆÁÇ?
     */
    drawDataPoints(ctx, chartData, padding, chartWidth, chartHeight, minValue, valueRange) {
        chartData.forEach((point, index) => {
            const x = padding + (chartWidth / (chartData.length - 1)) * index;
            const y = padding + chartHeight - ((point.value - minValue) / valueRange) * chartHeight;
            
            // Ê†πÊçÆÊ∏©Â∫¶ÂÄºÈÄâÊã©È¢úËâ≤
            let pointColor = '#2E7D32'; // Ê≠£Â∏∏
            if (point.value < this.thresholds.min || point.value > this.thresholds.max) {
                pointColor = '#F44336'; // Âç±Èô©
            } else if (point.value < this.thresholds.optimal.min || point.value > this.thresholds.optimal.max) {
                pointColor = '#FF9800'; // Ë≠¶Âëä
            }
            
            ctx.fillStyle = pointColor;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, 2 * Math.PI);
            ctx.fill();
        });
    }

    /**
     * Êõ¥Êñ∞ÂõæË°®ÂùêÊ†áËΩ?
     */
    updateChartAxes(data) {
        // Êõ¥Êñ∞XËΩ¥ÔºàÊó∂Èó¥ËΩ¥Ôºâ
        const xAxisEl = document.getElementById('chart-x-axis');
        if (xAxisEl && data.length > 0) {
            const timeLabels = [];
            const step = Math.max(1, Math.floor(data.length / 6));
            
            for (let i = 0; i < data.length; i += step) {
                timeLabels.push(data[i].label);
            }
            
            xAxisEl.innerHTML = timeLabels.map(label => `<span>${label}</span>`).join('');
        }
        
        // Êõ¥Êñ∞YËΩ¥ÔºàÊ∏©Â∫¶ËΩ¥Ôºâ
        const yAxisEl = document.getElementById('chart-y-axis');
        if (yAxisEl && data.length > 0) {
            const values = data.map(d => d.value);
            const minVal = Math.min(...values);
            const maxVal = Math.max(...values);
            const range = maxVal - minVal;
            const step = range / 5;
            
            const tempLabels = [];
            for (let i = 0; i <= 5; i++) {
                tempLabels.push((maxVal - i * step).toFixed(1) + '¬∞C');
            }
            
            yAxisEl.innerHTML = tempLabels.map(label => `<span>${label}</span>`).join('');
        }
    }

    /**
     * Ê†ºÂºèÂåñÊó∂Èó¥Ê†áÁ≠?
     */
    formatTimeLabel(date) {
        const d = new Date(date);
        return `${d.getHours().toString().padStart(2, '0')}:${d.getMinutes().toString().padStart(2, '0')}`;
    }

    /**
     * Ê£ÄÊü•Ê∏©Â∫¶ÈòàÂÄ?
     */
    checkThresholds() {
        if (!this.currentData) return;
        
        const temperature = parseFloat(this.currentData.temperature);
        const autoAlert = document.getElementById('auto-alert')?.checked;
        const autoControl = document.getElementById('auto-control')?.checked;
        
        // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊä•Ë≠?
        if (autoAlert && (temperature < this.thresholds.min || temperature > this.thresholds.max)) {
            this.addTemperatureAlert(temperature);
            
            // ÂèëÈÄÅÁ≥ªÁªüÈÄöÁü•
            if (temperature < this.thresholds.min) {
                notificationUtils.showSystemNotification('Ê∏©Â∫¶Êä•Ë≠¶', `Ê∏©Â∫¶Ëøá‰Ωé: ${temperature.toFixed(1)}¬∞C`);
            } else {
                notificationUtils.showSystemNotification('Ê∏©Â∫¶Êä•Ë≠¶', `Ê∏©Â∫¶ËøáÈ´ò: ${temperature.toFixed(1)}¬∞C`);
            }
        }
        
        // Ëá™Âä®ÊéßÂà∂ÈÄªËæë
        if (autoControl) {
            this.performAutoControl(temperature);
        }
    }
    
    /**
     * ÊâßË°åËá™Âä®ÊéßÂà∂
     */
    async performAutoControl(temperature) {
        try {
            if (temperature < this.thresholds.optimal.min) {
                // Ê∏©Â∫¶Ëøá‰ΩéÔºåÂêØÂä®Âä†ÁÉ≠Âô®
                await apiService.controlDevice('heater_01', {
                    action: 'start',
                    powerLevel: Math.min(100, (this.thresholds.optimal.min - temperature) * 10)
                }, { showError: false });
                
                // ÂÖ≥Èó≠ÂÜ∑Âç¥Âô?
                await apiService.controlDevice('cooler_01', {
                    action: 'stop'
                }, { showError: false });
                
            } else if (temperature > this.thresholds.optimal.max) {
                // Ê∏©Â∫¶ËøáÈ´òÔºåÂêØÂä®ÂÜ∑Âç¥Âô®
                await apiService.controlDevice('cooler_01', {
                    action: 'start',
                    powerLevel: Math.min(100, (temperature - this.thresholds.optimal.max) * 10)
                }, { showError: false });
                
                // ÂÖ≥Èó≠Âä†ÁÉ≠Âô?
                await apiService.controlDevice('heater_01', {
                    action: 'stop'
                }, { showError: false });
                
            } else {
                // Ê∏©Â∫¶Ê≠£Â∏∏ÔºåÂÖ≥Èó≠Âä†ÁÉ≠ÂíåÂÜ∑Âç¥ËÆæÂ§á
                await apiService.controlDevice('heater_01', { action: 'stop' }, { showError: false });
                await apiService.controlDevice('cooler_01', { action: 'stop' }, { showError: false });
            }
        } catch (error) {
            console.error('Ëá™Âä®ÊéßÂà∂Â§±Ë¥•:', error);
        }
    }

    /**
     * Ê∑ªÂä†Ê∏©Â∫¶ÂºÇÂ∏∏ËÆ∞ÂΩï
     */
    addTemperatureAlert(temperature) {
        const alertsContainer = document.getElementById('temperature-alerts');
        if (!alertsContainer) return;
        
        const alertType = temperature < this.thresholds.min ? 'Ê∏©Â∫¶Ëøá‰Ωé' : 'Ê∏©Â∫¶ËøáÈ´ò';
        const alertClass = 'status-danger';
        const timestamp = new Date().toLocaleString();
        
        const alertHtml = `
            <div class="data-display">
                <div class="data-label">${timestamp}</div>
                <div class="data-value">
                    <span class="data-status ${alertClass}">${alertType}</span>
                    <span>${temperature.toFixed(1)}¬∞C</span>
                </div>
            </div>
        `;
        
        alertsContainer.insertAdjacentHTML('afterbegin', alertHtml);
        
        // ÈôêÂà∂ÊòæÁ§∫ÊúÄËø?0Êù°ËÆ∞ÂΩ?
        const alerts = alertsContainer.querySelectorAll('.data-display');
        if (alerts.length > 10) {
            alerts[alerts.length - 1].remove();
        }
    }

    /**
     * È™åËØÅÈòàÂÄºËÆæÁΩ?
     */
    validateThresholds() {
        const minThreshold = parseFloat(document.getElementById('min-threshold')?.value || 0);
        const maxThreshold = parseFloat(document.getElementById('max-threshold')?.value || 50);
        const optimalMin = parseFloat(document.getElementById('optimal-min-threshold')?.value || 20);
        const optimalMax = parseFloat(document.getElementById('optimal-max-threshold')?.value || 28);
        
        let isValid = true;
        let message = '';
        
        if (minThreshold >= maxThreshold) {
            isValid = false;
            message = 'ÊúÄ‰ΩéÊ∏©Â∫¶ÈòàÂÄºÂøÖÈ°ªÂ∞è‰∫éÊúÄÈ´òÊ∏©Â∫¶ÈòàÂÄ?;
        } else if (optimalMin < minThreshold || optimalMax > maxThreshold) {
            isValid = false;
            message = 'ÊúÄÈÄÇÊ∏©Â∫¶ËåÉÂõ¥ÂøÖÈ°ªÂú®Ê∏©Â∫¶ÈòàÂÄºËåÉÂõ¥ÂÜÖ';
        } else if (optimalMin >= optimalMax) {
            isValid = false;
            message = 'ÊúÄÈÄÇÊ∏©Â∫¶‰∏ãÈôêÂøÖÈ°ªÂ∞è‰∫é‰∏äÈô?;
        }
        
        if (!isValid) {
            notificationUtils.warning(message);
            return false;
        }
        
        return true;
    }

    /**
     * ‰øùÂ≠òÈòàÂÄºËÆæÁΩ?
     */
    async saveThresholds() {
        if (!this.validateThresholds()) {
            return;
        }
        
        const thresholds = {
            min: parseFloat(document.getElementById('min-threshold')?.value || 0),
            max: parseFloat(document.getElementById('max-threshold')?.value || 50),
            optimal: {
                min: parseFloat(document.getElementById('optimal-min-threshold')?.value || 20),
                max: parseFloat(document.getElementById('optimal-max-threshold')?.value || 28)
            },
            autoAlert: document.getElementById('auto-alert')?.checked || false,
            autoControl: document.getElementById('auto-control')?.checked || false
        };
        
        try {
            await apiService.setEnvironmentThreshold({
                type: 'temperature',
                ...thresholds
            });
            
            this.thresholds = thresholds;
            notificationUtils.success('Ê∏©Â∫¶ÈòàÂÄºËÆæÁΩÆÂ∑≤‰øùÂ≠ò');
            
        } catch (error) {
            console.error('‰øùÂ≠òÈòàÂÄºËÆæÁΩÆÂ§±Ë¥?', error);
            notificationUtils.error('‰øùÂ≠òÈòàÂÄºËÆæÁΩÆÂ§±Ë¥•ÔºåËØ∑ÈáçËØ?);
        }
    }

    /**
     * ÂØºÂá∫Êï∞ÊçÆ
     */
    async exportData() {
        try {
            const period = document.querySelector('.period-btn.active')?.dataset.period || '24h';
            const response = await apiService.exportHistoryData({
                type: 'temperature',
                period: period,
                format: 'csv'
            });
            
            if (response && response.data) {
                // ÂàõÂª∫‰∏ãËΩΩÈìæÊé•
                const blob = new Blob([response.data], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `temperature_data_${period}_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                notificationUtils.success('Êï∞ÊçÆÂØºÂá∫ÊàêÂäü');
            }
        } catch (error) {
            console.error('ÂØºÂá∫Êï∞ÊçÆÂ§±Ë¥•:', error);
            notificationUtils.error('ÂØºÂá∫Êï∞ÊçÆÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
        }
    }

    /**
     * Ê∏ÖÈô§ÂºÇÂ∏∏ËÆ∞ÂΩï
     */
    clearAlerts() {
        const alertsContainer = document.getElementById('temperature-alerts');
        if (alertsContainer) {
            alertsContainer.innerHTML = '<div class="empty-state"><div class="empty-state-description">ÊöÇÊó†ÂºÇÂ∏∏ËÆ∞ÂΩï</div></div>';
            notificationUtils.success('ÂºÇÂ∏∏ËÆ∞ÂΩïÂ∑≤Ê∏ÖÈô?);
        }
    }

    /**
     * ÂêØÂä®Ëá™Âä®Âà∑Êñ∞
     */
    startAutoRefresh() {
        // ÊØ?0ÁßíÂà∑Êñ∞‰∏ÄÊ¨°Êï∞Êç?
        this.refreshInterval = setInterval(() => {
            this.refresh();
        }, 30000);
    }

    /**
     * ÁîüÊàêÊ®°ÊãüÊï∞ÊçÆ
     */
    generateMockData() {
        return {
            temperature: (20 + Math.random() * 15).toFixed(1),
            recordedAt: new Date().toISOString()
        };
    }

    /**
     * ÁîüÊàêÊ®°ÊãüÂéÜÂè≤Êï∞ÊçÆ
     */
    generateMockHistoryData(period) {
        const data = [];
        let count = 24; // ÈªòËÆ§24Â∞èÊó∂
        let interval = 60 * 60 * 1000; // 1Â∞èÊó∂Èó¥Èöî
        
        if (period === '7d') {
            count = 7 * 24;
            interval = 60 * 60 * 1000; // 1Â∞èÊó∂Èó¥Èöî
        } else if (period === '30d') {
            count = 30;
            interval = 24 * 60 * 60 * 1000; // 1Â§©Èó¥Èö?
        }
        
        const baseTemp = 25;
        let currentTemp = baseTemp;
        
        for (let i = count - 1; i >= 0; i--) {
            // Ê®°ÊãüÊ∏©Â∫¶ÂèòÂåñ
            const variation = (Math.random() - 0.5) * 4; // ¬±2Â∫¶ÂèòÂå?
            currentTemp = Math.max(15, Math.min(35, currentTemp + variation));
            
            data.push({
                temperature: currentTemp.toFixed(1),
                recordedAt: new Date(Date.now() - i * interval).toISOString()
            });
        }
        
        return data;
    }

    /**
     * Â§ÑÁêÜÂÆûÊó∂Êï∞ÊçÆÊõ¥Êñ∞
     * @param {Object} data - ÂÆûÊó∂ÁéØÂ¢ÉÊï∞ÊçÆ
     */
    updateEnvironmentData(data) {
        if (data && data.temperature !== undefined) {
            this.currentData = data;
            this.updateDisplay();
            this.updateGauge();
            this.checkThresholds();
            
            // Êõ¥Êñ∞ÂéÜÂè≤Êï∞ÊçÆÔºà‰øùÊåÅÊúÄÊñ∞ÁöÑÊï∞ÊçÆÂú®ÂâçÈù¢Ôºâ
            this.historyData.unshift({
                temperature: data.temperature,
                recordedAt: data.recordedAt || new Date().toISOString()
            });
            
            // ÈôêÂà∂ÂéÜÂè≤Êï∞ÊçÆÈïøÂ∫¶
            if (this.historyData.length > 100) {
                this.historyData = this.historyData.slice(0, 100);
            }
            
            // ÈáçÁªòÂõæË°®
            this.drawTrendChart();
        }
    }
    
    /**
     * Â§ÑÁêÜÁ™óÂè£Â§ßÂ∞èÂèòÂåñ
     */
    onResize() {
        // ÈáçÊñ∞ÁªòÂà∂ÂõæË°®‰ª•ÈÄÇÂ∫îÊñ∞ÁöÑÂ∞∫ÂØ∏
        setTimeout(() => {
            this.drawTrendChart();
            this.updateGauge();
        }, 100);
    }
    
    /**
     * Ëé∑ÂèñÁªÑ‰ª∂Áä∂ÊÄ?
     */
    getStatus() {
        return {
            currentTemperature: this.currentData ? parseFloat(this.currentData.temperature) : null,
            thresholds: this.thresholds,
            historyDataCount: this.historyData.length,
            isAutoRefreshEnabled: !!this.refreshInterval
        };
    }
    
    /**
     * ÈáçÁΩÆÁªÑ‰ª∂Áä∂ÊÄ?
     */
    reset() {
        this.currentData = null;
        this.historyData = [];
        
        // Ê∏ÖÁ©∫ÊòæÁ§∫
        const elements = [
            'temp-value', 'temp-status', 'sensor-status',
            'max-temp', 'min-temp', 'avg-temp', 'trend-text'
        ];
        
        elements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = '--';
            }
        });
        
        // Ê∏ÖÁ©∫ÂõæË°®
        if (this.chartCanvas) {
            const ctx = this.chartCanvas.getContext('2d');
            ctx.clearRect(0, 0, this.chartCanvas.width, this.chartCanvas.height);
        }
        
        // Ê∏ÖÁ©∫ÂºÇÂ∏∏ËÆ∞ÂΩï
        this.clearAlerts();
    }
    
    /**
     * ÈîÄÊØÅÁªÑ‰ª?
     */
    destroy() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval);
            this.refreshInterval = null;
        }
        
        this.reset();
        this.chartCanvas = null;
        
        console.log('Ê∏©Â∫¶ÁõëÊéßÁªÑ‰ª∂Â∑≤ÈîÄÊØ?);
    }
}

// ÂàõÂª∫ÂÖ®Â±ÄÊ∏©Â∫¶ÁªÑ‰ª∂ÂÆû‰æã
const temperatureComponent = new TemperatureComponent();
